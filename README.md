# Rolling Solo

프로젝트 기술 스택과 각 선택의 이유에 대한 문서입니다.

## 기술 스택

### 핵심 프레임워크 및 라이브러리

| 기술 | 버전 | 선택 이유 |
|------|------|----------|
| **Next.js** | 14.2.4 | 서버 사이드 렌더링(SSR)과 정적 사이트 생성(SSG)을 지원하여 SEO 최적화와 초기 로딩 성능을 향상시킵니다. 또한 App Router를 통한 직관적인 라우팅 시스템을 사용하였습니다. |
| **React** | 18 | 컴포넌트 기반 아키텍처로 재사용 가능한 UI 요소를 만들고 관리할 수 있으며, 가상 DOM을 통해 효율적인 렌더링이 가능합니다. |
| **TypeScript** | 5.4.0 | 정적 타입시스템을 사용하여, 발생가능한 오류를 최소화하였고, 코드 품질과 유지보수성을 향상시킵니다. |
| **Scss** | 1.75.0 | CSS의 확장 문법을 제공하여 변수, 중첩 규칙, 믹스인 등을 활용해 스타일링을 더 체계적으로 관리할 수 있습니다. CSS Module 방식과 함께 사용하여 스타일의 범위를 컴포넌트로 제한하는 방식으로 사용하였습니다. |

### 상태 관리

| 기술 | 버전 | 선택 이유 |
|------|------|----------|
| **Zustand** | 4.5.2 | Store 단위의 간결한 API를 기반으로, 보일러플레이트 코드를 최소화합니다. 작은 크기와 높은 성능으로 글로벌 상태 관리를 단순화합니다. |
| **React Query** | 5.68.0 | 서버 상태 관리를 위한 라이브러리로, 데이터 캐싱, 재시도, 무효화 등의 기능을 제공하여 API 요청 관리를 간소화합니다. |

### API 통신

| 기술 | 버전 | 선택 이유 |
|------|------|----------|
| **Axios** | 1.6.7 |fetch API보다 더 풍부한 기능을 제공하며, 요청과 응답을 자동으로 가로채서 전역적으로 처리할 수 있어 인증 토큰 관리나 에러 핸들링등응 위한 인터셉터나 요청 취소 기능과 자동 JSON 변환, 타임아웃 설정 등이 미들웨어로서 활용 가능하다는 점에서 선택.|

### 폼 관리

| 기술 | 버전 | 선택 이유 |
|------|------|----------|
| **React Hook Form** | 7.51.0 | 복잡한 폼상태를 위임하여, 불필요한 페이지 로직을 최소화하기위해 사용. |


### 리치 텍스트 에디터

| 기술 | 버전 | 선택 이유 |
|----------|------|----------|
| **edit-on-slate** || slate.js 기반의 에디터로 직접 개발하여 npm패키지 배포후 사용하였다. prose mirror 등을 활용한 개발도 염두에 두었으나, 메타 라이브러리나 스키마 없이 dom모델을 기반으로 로직을 짤 수 있다는 점이 흥미로웠다. |


### 개발 도구

| 기술 | 버전 | 선택 이유 |
|------|------|----------|
| **Storybook** | 8.1.10 | 컴포넌트 단위 개발과 문서화를 지원하며, UI 컴포넌트를 독립적으로 테스트하고 시각화. |
| **Jest** | 29.7.0 |단위 테스트와 통합 테스트를 위해 사용. 주로 컴포넌트 개발전 api 메서드 테스트를 위해 사용하였다. |

### 코드 품질 관리

| 기술 | 버전 | 선택 이유 |
|------|------|----------|
| **ESLint** | 8 | JavaScript와 TypeScript 코드의 정적 분석 도구로, 코드 스타일과 잠재적인 문제를 식별합니다. |

## 프로젝트 구조

프로젝트는 컴포넌트 콜로케이션 원칙을 따르며 다음과 같이 구성되어 있습니다:

1. 컴포넌트 파일은 기본적으로 `.tsx`와 `.scss` 파일 쌍으로 구성
2. 특정 상위 컴포넌트에만 사용되는 하위 컴포넌트는 해당 상위 컴포넌트의 폴더에 위치
3. 페이지 로직에만 사용되는 컴포넌트는 해당 페이지 폴더의 `_components` 폴더에 배치
  - collocation 원칙을 따르되, next에서 app routing을 피하기 위함.

```
components/
  ├── [공통 컴포넌트들]
  └── ComponentA/
      ├── ComponentA.tsx
      ├── ComponentA.module.scss
      └── SubComponent/
          ├── SubComponent.tsx
          └── SubComponent.module.scss

app/
  └── page-route/
      ├── page.tsx
      └── _components/
          └── [페이지 전용 컴포넌트들]
```


## 성능 최적화 내용

- React Query 캐싱 전략
  - 데이터 유형에 따른 staleTime 및 gcTime 차등 적용
  - 에러 재시도 전략 최적화

- 컴포넌트 최적화
  - React.memo, useCallback, useMemo를 통한 불필요한 리렌더링 방지
  - 동적 임포트를 통한 코드 분할

## 유지보수 가이드

### 서버 상태 관리 (React Query)

```tsx
// 쿼리 사용 예시
const { data, isLoading } = useQuery({
  queryKey: ['recipients', id],
  queryFn: () => getRecipientsById({ id }),
});

// 뮤테이션 사용 예시
const mutation = useMutation({
  mutationFn: postRecipients,
  onSuccess: () => {
    queryClient.invalidateQueries({ queryKey: ['recipients'] });
  },
});
```

### 컴포넌트 개발 가이드

- 컴포넌트는 단일 책임 원칙을 따릅니다.
- 재사용 가능한 UI 요소는 components/ 디렉토리에 위치시킵니다.
- 페이지 특정 컴포넌트는 app/[page]/_components/에 위치시킵니다.
- 모든 컴포넌트는 Storybook으로 문서화합니다.

### 상태 관리 전략

- **지역 상태**: React useState, useReducer
- **서버 상태**: React Query
- **글로벌 UI 상태**: Zustand
- **폼 상태**: React Hook Form